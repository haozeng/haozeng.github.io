<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Hao's Blog]]></title>
  <link href="http://haozeng.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://haozeng.github.io/"/>
  <updated>2014-06-08T23:03:27-07:00</updated>
  <id>http://haozeng.github.io/</id>
  <author>
    <name><![CDATA[Hao Zeng]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Twitter Streaming Retweets]]></title>
    <link href="http://haozeng.github.io/blog/2014/05/08/twitter-streaming-retweets/"/>
    <updated>2014-05-08T22:46:49-07:00</updated>
    <id>http://haozeng.github.io/blog/2014/05/08/twitter-streaming-retweets</id>
    <content type="html"><![CDATA[<p>Recently, I did an exercise using twitter streaming api to generate the most recent 10
retweets in the past n minutes.</p>

<p>The program is pretty simple. It sends http streaming requests to twitter api and doing sorting in the background thread, while the main thread is printing out the most recent 10 retweets.</p>

<p>```ruby</p>

<p>require &lsquo;twitter&rsquo;
require &lsquo;pry&rsquo;
require &lsquo;pp&rsquo;</p>

<p>class Streamer
  attr_reader :client, :background_thread, :mins, :container</p>

<p>  def initialize(attributes)</p>

<pre><code>@client = attributes[:client]
@mins = attributes[:mins]
@container = attributes[:container]
</code></pre>

<p>  end</p>

<p>  def stream</p>

<pre><code>@background_thread = Thread.new do
  @client.sample do |object|
    if object.is_a?(Twitter::Tweet)
      @container[object.created_at] ||= []
      @container[object.created_at] &lt;&lt; object.text
    end
    # Container will only keep tweets which are 5 mins up to date
    @container.keep_if {|time, tweet| @mins * 60 &gt; Time.now - time}
  end
end
</code></pre>

<p>  end</p>

<p>  def stop</p>

<pre><code>Thread.kill(@background_thread)
</code></pre>

<p>  end
end</p>

<p>class Massager
  attr_reader :raw_tweets, :top_tweets, :container</p>

<p>  def initialize(attributes)</p>

<pre><code>@container = attributes[:container]
</code></pre>

<p>  end</p>

<p>  def top_tweets</p>

<pre><code>build
sort
format
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def build</p>

<pre><code>@raw_tweets = Hash.new(0)
@container.values.flatten.each do |tweet|
  @raw_tweets[tweet] += 1
end
</code></pre>

<p>  end</p>

<p>  def sort</p>

<pre><code>@raw_tweets = @raw_tweets.sort{|a,b| a[1] &lt;=&gt; b[1]}.last(10)
</code></pre>

<p>  end</p>

<p>  def format</p>

<pre><code>@raw_tweets.inject({}) do |memo, value|
  memo[value[1]] ||= []
  memo[value[1]] &lt;&lt; value[0]
  memo
end
</code></pre>

<p>  end
end</p>

<p>class Manager
  attr_reader :container, :streamer, :massager</p>

<p>  def initialize(attributes)</p>

<pre><code>@container = {}
@streamer = Streamer.new(container: @container, mins: attributes[:mins], client: attributes[:client])
@massager = Massager.new(container: @container)
</code></pre>

<p>  end
end</p>

<p>client = Twitter::Streaming::Client.new do |config|
  config.consumer_key        = &ldquo;#&rdquo;
  config.consumer_secret     = &ldquo;#&rdquo;
  config.access_token        = &ldquo;#&rdquo;
  config.access_token_secret = &ldquo;#&rdquo;
end</p>

<p>mins = 1
manager = Manager.new(mins: mins, client: client)
manager.streamer.stream</p>

<p>start_time = Time.now
loop do
  window_start = Time.now &ndash; start_time > 60<em>mins ? Time.now &ndash; 60</em>mins : start_time
  sleep(1)
  puts &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; Top Ten Tweets from #{window_start} To #{Time.now} &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;&rdquo;
  pp manager.massager.top_tweets
end</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rotx and Compromise]]></title>
    <link href="http://haozeng.github.io/blog/2014/03/27/rotx-and-compromise/"/>
    <updated>2014-03-27T20:36:18-07:00</updated>
    <id>http://haozeng.github.io/blog/2014/03/27/rotx-and-compromise</id>
    <content type="html"><![CDATA[<p>Rotx exercise:</p>

<p>``` ruby
def rotx(x, string, encrypt=true)
  letters = (&lsquo;a&rsquo;..&lsquo;z&rsquo;).to_a</p>

<p>  string.split(&lsquo;&rsquo;).map! do |letter|</p>

<pre><code>if letter.match(/[a-zA-Z]/)
  # Looking for index
  index = letter == letter.downcase ? letters.index(letter) : letters.index(letter.downcase)

  # Building rotated index either by moving forward or backward
  rotated_index = encrypt ? (index + x)%26 : (index - x)%26

  # Building new letter based on rotated index
  letter == letter.downcase ? letters[rotated_index] : letters[rotated_index].upcase
else
  letter
end
</code></pre>

<p>  end.join
end</p>

<p>describe &lsquo;Test #rotx&rsquo; do
  it &lsquo;should rotate the string and encrypt as default&rsquo; do</p>

<pre><code>rotx(10, 'Hello, World').should eql 'Rovvy, Gybvn'
</code></pre>

<p>  end</p>

<p>  it &lsquo;should rotate back the string if encrypt is false&rsquo; do</p>

<pre><code>rotx(10, 'Rovvy, Gybvn', false).should eql 'Hello, World'
</code></pre>

<p>  end</p>

<p>  it &lsquo;should return the same results if roration number is added 26&rsquo; do</p>

<pre><code>rotx(36, 'Hello, World').should eql 'Rovvy, Gybvn'
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>A simple compromise implementation, and this will build the foundation in removing callbacks in node.js app.</p>

<p>``` javascript
Promise = function () {
  this.value;
  this.callbacks = [];
};</p>

<p>Promise.prototype.resolve = function(result) {
  if (this.value) {</p>

<pre><code>throw new Error('A promise should only be able to be resolved once !');
</code></pre>

<p>  } else {</p>

<pre><code>this.value = result;
</code></pre>

<p>  }
  if (this.callbacks.length > 0) {</p>

<pre><code>this.triggerCallbacks();
</code></pre>

<p>  }
};</p>

<p>Promise.prototype.success = function(fn) {
  this.callbacks.push(fn);</p>

<p>  if (this.value) {</p>

<pre><code>this.triggerCallbacks();
</code></pre>

<p>  }
};</p>

<p>Promise.prototype.triggerCallbacks = function() {
  var self = this;</p>

<p>  this.callbacks.forEach(function(callback) {</p>

<pre><code>callback.call(self,self.value);
</code></pre>

<p>  });
}</p>

<p>var foo = new Promise();
var bar = new Promise();</p>

<p>foo.resolve(&lsquo;hello&rsquo;);</p>

<p>setTimeout(function(){
  bar.resolve(&lsquo;world&rsquo;);
}, 500);</p>

<p>foo.success(function(result){
  console.log(result);
});</p>

<p>bar.success(function(result){
  console.log(result);
});</p>

<p>// Throw errors if one promise tries to resolve twice</p>

<p>var foobar = new Promise();
foobar.resolve(&lsquo;hello&rsquo;);
foobar.resolve(&lsquo;world&rsquo;);
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DFS and BFS in Ruby Using Simple Tree Objects]]></title>
    <link href="http://haozeng.github.io/blog/2014/01/05/trees-in-ruby/"/>
    <updated>2014-01-05T08:54:11-08:00</updated>
    <id>http://haozeng.github.io/blog/2014/01/05/trees-in-ruby</id>
    <content type="html"><![CDATA[<p>In Ruby, there is no existing pre-built tree structures available, but it is pretty easy to define
tree objects. Here is the an exmaple which DFS and BFS are performed using ruby.</p>

<p>``` ruby</p>

<p>class Node
  attr_accessor :value, :left, :right, :name</p>

<p>  def initialize(options={})</p>

<pre><code>@value = options[:value]
@name = options[:name]
</code></pre>

<p>  end</p>

<p>  def children</p>

<pre><code>[@left, @right].compact
</code></pre>

<p>  end</p>

<p>  def children?</p>

<pre><code>@left &amp;&amp; @right
</code></pre>

<p>  end</p>

<p>  def no_children?</p>

<pre><code>!children?
</code></pre>

<p>  end
end</p>

<p>root = Node.new({:value => 1, :name => &lsquo;root&rsquo;})
child_1 = Node.new({:value => 2, :name => &lsquo;child_1&rsquo;})
child_2 = Node.new({:value => 3, :name => &lsquo;child_2&rsquo;})
grand_child_1 = Node.new({:value => 4, :name => &lsquo;grand_child_1&rsquo;})
grand_grand_child_1 = Node.new({:value => 5, :name => &lsquo;grand_grand_child_1&rsquo;})
grand_child_1.left = grand_grand_child_1
child_1.left = grand_child_1
root.left = child_1
root.right = child_2</p>

<p>def bfs(node)
  queue = []
  queue.push(node)</p>

<p>  while(queue.size != 0)</p>

<pre><code>n = queue.shift
puts n.value
n.children.each do |child|
  queue.push(child)
end
</code></pre>

<p>  end
end</p>

<p>bfs(root)</p>

<p>puts &lsquo;~~~~~~~~~~~~~~~~~~~~~~~~~~~&rsquo;</p>

<p>def dfs(node)
  puts node.value
  node.children.each do |child|</p>

<pre><code>dfs(child)
</code></pre>

<p>  end
end</p>

<p>dfs(root)</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Create Multiple Varariables With Differentreferences in Ruby]]></title>
    <link href="http://haozeng.github.io/blog/2013/01/30/multiple-variables-same-value-in-ruby/"/>
    <updated>2013-01-30T19:25:50-08:00</updated>
    <id>http://haozeng.github.io/blog/2013/01/30/multiple-variables-same-value-in-ruby</id>
    <content type="html"><![CDATA[<p>Today I had a bug in ruby which I do not quite understand, and it turned out to be reference issue in ruby.</p>

<p>First, I tried something like this and intended to create 4 variables for the same values, but different objects</p>

<p>```ruby</p>

<p>a, b, c ,d = [Object.new] * 4</p>

<p>```
This turns out to be a, b, c, d refers to the same object</p>

<p>```ruby
a.object_id == b.object_id</p>

<h1>=> true</h1>

<p>```
So the correct way should be:</p>

<p><code>ruby
a, b, c, d = Object.new, Object.new, Object.new, Object.new
</code></p>
]]></content>
  </entry>
  
</feed>
