<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Hao's Blog]]></title>
  <link href="http://haozeng.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://haozeng.github.io/"/>
  <updated>2014-04-01T20:41:16-07:00</updated>
  <id>http://haozeng.github.io/</id>
  <author>
    <name><![CDATA[Hao Zeng]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rotx and Compromise]]></title>
    <link href="http://haozeng.github.io/blog/2014/03/27/rotx-and-compromise/"/>
    <updated>2014-03-27T20:36:18-07:00</updated>
    <id>http://haozeng.github.io/blog/2014/03/27/rotx-and-compromise</id>
    <content type="html"><![CDATA[<p>Rotx exercise:</p>

<p>``` ruby
def rotx(x, string, encrypt=true)
  letters = (&lsquo;a&rsquo;..&lsquo;z&rsquo;).to_a</p>

<p>  string.split(&lsquo;&rsquo;).map! do |letter|</p>

<pre><code>if letter.match(/[a-zA-Z]/)
  # Looking for index
  index = letter == letter.downcase ? letters.index(letter) : letters.index(letter.downcase)

  # Building rotated index either by moving forward or backward
  rotated_index = encrypt ? (index + x)%26 : (index - x)%26

  # Building new letter based on rotated index
  letter == letter.downcase ? letters[rotated_index] : letters[rotated_index].upcase
else
  letter
end
</code></pre>

<p>  end.join
end</p>

<p>describe &lsquo;Test #rotx&rsquo; do
  it &lsquo;should rotate the string and encrypt as default&rsquo; do</p>

<pre><code>rotx(10, 'Hello, World').should eql 'Rovvy, Gybvn'
</code></pre>

<p>  end</p>

<p>  it &lsquo;should rotate back the string if encrypt is false&rsquo; do</p>

<pre><code>rotx(10, 'Rovvy, Gybvn', false).should eql 'Hello, World'
</code></pre>

<p>  end</p>

<p>  it &lsquo;should return the same results if roration number is added 26&rsquo; do</p>

<pre><code>rotx(36, 'Hello, World').should eql 'Rovvy, Gybvn'
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>A simple compromise implementation, and this will build the foundation in removing callbacks in node.js app.</p>

<p>``` javascript
Promise = function () {
  this.value;
  this.callbacks = [];
};</p>

<p>Promise.prototype.resolve = function(result) {
  if (this.value) {</p>

<pre><code>throw new Error('A promise should only be able to be resolved once !');
</code></pre>

<p>  } else {</p>

<pre><code>this.value = result;
</code></pre>

<p>  }
  if (this.callbacks.length > 0) {</p>

<pre><code>this.triggerCallbacks();
</code></pre>

<p>  }
};</p>

<p>Promise.prototype.success = function(fn) {
  this.callbacks.push(fn);</p>

<p>  if (this.value) {</p>

<pre><code>this.triggerCallbacks();
</code></pre>

<p>  }
};</p>

<p>Promise.prototype.triggerCallbacks = function() {
  var self = this;</p>

<p>  this.callbacks.forEach(function(callback) {</p>

<pre><code>callback.call(self,self.value);
</code></pre>

<p>  });
}</p>

<p>var foo = new Promise();
var bar = new Promise();</p>

<p>foo.resolve(&lsquo;hello&rsquo;);</p>

<p>setTimeout(function(){
  bar.resolve(&lsquo;world&rsquo;);
}, 500);</p>

<p>foo.success(function(result){
  console.log(result);
});</p>

<p>bar.success(function(result){
  console.log(result);
});</p>

<p>// Throw errors if one promise tries to resolve twice</p>

<p>var foobar = new Promise();
foobar.resolve(&lsquo;hello&rsquo;);
foobar.resolve(&lsquo;world&rsquo;);
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DFS and BFS in Ruby Using Simple Tree Objects]]></title>
    <link href="http://haozeng.github.io/blog/2014/01/05/trees-in-ruby/"/>
    <updated>2014-01-05T08:54:11-08:00</updated>
    <id>http://haozeng.github.io/blog/2014/01/05/trees-in-ruby</id>
    <content type="html"><![CDATA[<p>In Ruby, there is no existing pre-built tree structures available, but it is pretty easy to define
tree objects. Here is the an exmaple which DFS and BFS are performed using ruby.</p>

<p>``` ruby</p>

<p>class Node
  attr_accessor :value, :left, :right, :name</p>

<p>  def initialize(options={})</p>

<pre><code>@value = options[:value]
@name = options[:name]
</code></pre>

<p>  end</p>

<p>  def children</p>

<pre><code>[@left, @right].compact
</code></pre>

<p>  end</p>

<p>  def children?</p>

<pre><code>@left &amp;&amp; @right
</code></pre>

<p>  end</p>

<p>  def no_children?</p>

<pre><code>!children?
</code></pre>

<p>  end
end</p>

<p>root = Node.new({:value => 1, :name => &lsquo;root&rsquo;})
child_1 = Node.new({:value => 2, :name => &lsquo;child_1&rsquo;})
child_2 = Node.new({:value => 3, :name => &lsquo;child_2&rsquo;})
grand_child_1 = Node.new({:value => 4, :name => &lsquo;grand_child_1&rsquo;})
grand_grand_child_1 = Node.new({:value => 5, :name => &lsquo;grand_grand_child_1&rsquo;})
grand_child_1.left = grand_grand_child_1
child_1.left = grand_child_1
root.left = child_1
root.right = child_2</p>

<p>def bfs(node)
  queue = []
  queue.push(node)</p>

<p>  while(queue.size != 0)</p>

<pre><code>n = queue.shift
puts n.value
n.children.each do |child|
  queue.push(child)
end
</code></pre>

<p>  end
end</p>

<p>bfs(root)</p>

<p>puts &lsquo;~~~~~~~~~~~~~~~~~~~~~~~~~~~&rsquo;</p>

<p>def dfs(node)
  puts node.value
  node.children.each do |child|</p>

<pre><code>dfs(child)
</code></pre>

<p>  end
end</p>

<p>dfs(root)</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Create Multiple Varariables With Differentreferences in Ruby]]></title>
    <link href="http://haozeng.github.io/blog/2013/01/30/multiple-variables-same-value-in-ruby/"/>
    <updated>2013-01-30T19:25:50-08:00</updated>
    <id>http://haozeng.github.io/blog/2013/01/30/multiple-variables-same-value-in-ruby</id>
    <content type="html"><![CDATA[<p>Today I had a bug in ruby which I do not quite understand, and it turned out to be reference issue in ruby.</p>

<p>First, I tried something like this and intended to create 4 variables for the same values, but different objects</p>

<p>```ruby</p>

<p>a, b, c ,d = [Object.new] * 4</p>

<p>```
This turns out to be a, b, c, d refers to the same object</p>

<p>```ruby
a.object_id == b.object_id</p>

<h1>=> true</h1>

<p>```
So the correct way should be:</p>

<p><code>ruby
a, b, c, d = Object.new, Object.new, Object.new, Object.new
</code></p>
]]></content>
  </entry>
  
</feed>
